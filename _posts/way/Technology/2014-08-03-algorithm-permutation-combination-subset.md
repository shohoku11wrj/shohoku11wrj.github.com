---
layout: post
title: Algorithm -- Permutation Combination Subset
category: Technology
tag: ['algorithm','java', 'Permutation', 'Combination', 'Subset', 'DFS', 'Binary Operation']
lan: EN
---

Given a collection of numbers, return all possible `Permutations`, `K-Combinations`, or all `Subsets` are the most fundamental questions in algorithm.

They can be impelmented by simple `recursion`, `iteration`, `bit-operation`, and some other approaches. I mostly use Java to code in this post.

<!--preview-->

## Permutation

<blockquote>
Given a collection of numbers, return all possible permutations.
<br/>
For example, <br/>
    [1,2,3] have the following permutations: <br/>
    [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
</blockquote>

also see: CrackingCoding: [C9Q5](https://github.com/gaylemcd/ctci/blob/master/java/Chapter%209/Question9_5/Question.java), LeetCode: [Permutations](https://oj.leetcode.com/problems/permutations/)

Time Complexity: `\(O(n!)\)`

### Recursion -- DFS

The idea of iteration to solve this problem is dervied from Depth First Search (DFS).

![structure of DFS tree](http://img.blog.csdn.net/20131026222331343)

Along with the increasing of recursing depth, the `amount number of subnodes` of each node is decreasing by one. This is why the time complexity is `\(O(n!)\)`.

    public ArrayList<int[]> perm(int[] num) {
      ArrayList<int[]> result = new ArrayList<int[]>();
      perm(0, num.length - 1, num, result);
      return result;
    }

    public void perm(int start, int end, int[] num, ArrayList<int[]> result) {
      if (start == end) {
        int[] arr = (int[]) num.clone();
        result.add(arr);
        return;
      }

      for (int i = start; i <= end; i++) {
        swap(num, start, i);
        perm(start + 1, end, num, result);
        swap(num, start, i);
      }
    }

    public void swap(int[] num, int start, int end) {
      int tmp = num[start];
      num[start] = num[end];
      num[end] = tmp;
    }

### Recursion -- Generated by Permutation(n-1)

The same solution as that of CrackingCoding. Insert the current number at every possible position into each of the last permutations.

    public List<List<Integer>> permute(int[] num) {
        if (num == null || num.length == 0) {
            return new ArrayList<List<Integer>>();
        }
        return permute(num, num.length - 1);
    }

    public List<List<Integer>> permute(int[] num, int ed) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (ed == 0) {
            List<Integer> one = new ArrayList<Integer>();
            one.add(num[ed]);
            res.add(one);
            return res;
        }

        List<List<Integer>> lastRes = permute(num, ed - 1);
        for (List<Integer> lastOne : lastRes) {
            for (int i = 0; i < lastOne.size(); i++) {
                lastOne.add(i, num[ed]);
                List<Integer> one = new ArrayList<Integer>(lastOne);
                lastOne.remove(i);
                res.add(one);
            }
            lastOne.add(num[ed]);
            res.add(lastOne);
        }
        return res;
    }

### Iteration -- Next Permutation

The iteration idea is derivered from a solution for [Next Permutation](https://oj.leetcode.com/problems/next-permutation/). It could also be used to solve [Unique Permutation](https://oj.leetcode.com/problems/permutations-ii/submissions/), while there are duplicated characters existed in the given array.

<blockquote>
For example, <br/>
[1,1,2] have the following unique permutations: <br/>
[1,1,2], [1,2,1], and [2,1,1].
</blockquote>

The function of `nextPermutation(int[] num)` is used to generate the smallest permutation among the possible permutations which are greater than the given `int[] num` in numeric concept.

<blockquote>
Here are some examples of `nextPermutation` <br/>
1,2,3 → 1,3,2 <br/>
3,2,1 → 1,2,3 <br/>
1,1,5 → 1,5,1
</blockquote>

    public ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
        Arrays.sort(num);
        ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();
        do {
            ArrayList<Integer> l = new ArrayList<Integer>();
            for (int n : num) {
                l.add(n);
            }
            ans.add(l);
        } while (nextPermutation(num));
        return ans;
    }

    private boolean nextPermutation(int[] num) {
        if (num.length <= 1) {
            return false;
        }
        int i = num.length - 1;
        while (true) {
            i--;
            if (num[i] < num[i + 1]) {
                int j = num.length;

                while (num[i] >= num[--j]) {}
    // !!! This non-content loop is useful to set the position of j, 
    // UNTIL `num[i] < num[j]`

                swap(num, i, j);
                reverse(num, i + 1, num.length);
                return true;
            }
            if (i == 0) {
                reverse(num, 0, num.length); //!!! back to the first smallest array
                return false;
            }
        }
    }

    private void swap(int[] num, int i, int j) {
        int temp = num[i];
        num[i] = num[j];
        num[j] = temp;
    }

    private void reverse(int[] num, int begin, int end) {
        end--;
        while (begin < end) {
            swap(num, begin++, end--);
        }
    }

## Combination

<blockquote>
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
<br/>
For example, <br/>
If n = 4 and k = 2, a solution is:
<br/>
[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4] ]
</blockquote>

also see: LeetCode: [Combinations](https://oj.leetcode.com/problems/combinations/)

Time Complexity: `\(O(2^n)\)` without triming branches, `\(O(2^k)\)` with triming.

### Recursion -- DFS

![structure of DFS tree](http://img.blog.csdn.net/20131026222338281)

    public ArrayList<ArrayList<Integer>> combine(int n, int k) {
      ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
      combine(0, n, k, new ArrayList<Integer>(), result);
      return result;
    }

    public void combine(int depth, int n, int k,
        ArrayList<Integer> r, ArrayList<ArrayList<Integer>> result)
    {
      if(r.size()==k)
      {
        result.add(new ArrayList<Integer>(r));
        return;
      }
      if(depth == n) return; //!!! triming branches

      r.add(depth + 1);
      combine(depth + 1, n, k, r, result);
      r.remove(r.size() - 1);
      combine(depth + 1, n, k, r, result);
    }

### Recursion -- Generated by Last Combination

e.g. combine(4,2): <br/>
depth == 0: [ ] <br/>
depth == 1: [1], __[2]__, [3], __[4]__ <br/>
depth == 2: [1,2], [1,3], [1,4], __[2,3], [2,4]__, [3,4]

    /* n is total numbers length: 1..n
       depth is current recursion depth
       k is final, used to trim branches */
    public ArrayList<ArrayList<Integer>> combine(int n, int depth, final int k) {
      ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();

      if (depth == 0) {
        ArrayList<Integer> empty = new ArrayList<Integer>();
        result.add(empty);
        return result;
      }

      ArrayList<ArrayList<Integer>> preRes = combine(n, depth - 1, k);
      for (ArrayList<Integer> one : preRes) {
        int last = one.isEmpty() ? 0 : one.get(depth - 2);
        for (int i = last + 1; i <= n; i++) {
          if (n - i + depth < k) { break; } // trim branches
          ArrayList<Integer> newOne = new ArrayList<Integer>(one);
          newOne.add(i);
          result.add(newOne);
        }
      }
      return result;
    }

## Subset

<blockquote>
Given a set of distinct integers, S, return all possible subsets.
</blockquote>

also see: CrackingCoding: [C9Q4](https://github.com/gaylemcd/ctci/blob/master/java/Chapter%209/Question9_4/Question.java), LeetCode: [Subsets](https://oj.leetcode.com/problems/subsets/)

Time Complexity: `\( O(2^n) \)`

### Recursion -- DFS

DFS of Subset is similar to that of Combination. Actually, Subset problem is to get all Combination from [n,0] to [n,n].

That is, NO triming branches during recursion. Retrieving all the results when recurion `depth == S.length`.

    public ArrayList<ArrayList<Integer>> subsets(int[] S) {
        int len = S.length;
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        subsets(S, 0, new ArrayList<Integer>(), result);
        return result;
    }

    static void subsets(int[] S, int depth, ArrayList<Integer> r, ArrayList<ArrayList<Integer>> result) {
        if (S.length == depth) {
            result.add(new ArrayList<Integer>(r));
            return;
        }

        r.add(S[depth]);
        subsets(S, depth + 1, r, result);
        r.remove(r.size() - 1);
        subsets(S, depth + 1, r, result);
    }

### Recursion -- Generated by Subsets(n -1)

Generating Subsets(n): compute Subsets(n-1), clone the results, and then add `\( a_n \)` to each of these cloned sets.

e.g. Subset(3) <br/>
Base case n = 0: __[]__ <br/>
Case n = 1: [], __[a1]__ <br/>
Case n = 2: [], [a1], __[a2], [a1,a2]__ <br/>
Case n = 3: [], [a1], [a2], [a1,a2], __[a3], [a1,a3], [a2,a3], [a1,a2,a3]__ <br/>

    public ArrayList<ArrayList<Integer>> getSubsets(ArrayList<Integer> set, int index) {
      ArrayList<ArrayList<Integer>> allsubsets;
      if (set.size() == index) { // Base case - add empty set
        allsubsets = new ArrayList<ArrayList<Integer>>();
        allsubsets.add(new ArrayList<Integer>()); 
      } else {
        allsubsets = getSubsets(set, index + 1);
        int item = set.get(index);
        ArrayList<ArrayList<Integer>> moresubsets = new ArrayList<ArrayList<Integer>>();
        for (ArrayList<Integer> subset : allsubsets) {
          ArrayList<Integer> newsubset = new ArrayList<Integer>();
          newsubset.addAll(subset); //
          newsubset.add(item);
          moresubsets.add(newsubset);
        }
        allsubsets.addAll(moresubsets);
      }
      return allsubsets;
    }

### Iteration -- Similar Logic as Previous, more Space Efficient

    public ArrayList<ArrayList<Integer>> subsets(int[] num) {
      Arrays.sort(num);
      ArrayList<ArrayList<Integer>> subsets = new ArrayList<ArrayList<Integer>>();
      subsets.add(new ArrayList<Integer>());
      for (int i = 0; i < num.length; i++) {
        int prevLast = subsets.size(); //!!!
        for (int j = 0; j < prevLast; j++) {
          ArrayList<Integer> subset = new ArrayList<Integer>(subsets.get(j));
          subset.add(num[i]);
          subsets.add(subset);
        }
      }
      return subsets;
    }

### Binary Operation

All subsets problem could be described as a unique problem: generating each one set from a number among 0 to `\( 2^n \)`, where n is the number of given set. Each set and number are one to one mapping.

explain: in order to get subsets from {1,2,3}, we need to do following choices when generating each one set: <br/>
pick {1} or not pick {1} <br/>
pick {2} or not pick {2} <br/>
pick {3} or not pick {3} <br/>
So, there are `\( 2^3 \)` possibilities altogether, exactly, the amount of subsets.

Each of those choices could be considered as a binary operation choice: `pick is 1, not pick is 0`. <br/>
Then, {} could be represented as `\(000_2 == 0_{10}\)`, {1} as `\(100_2 = 4_{10}\)`, {1,3} as `\(101_2 == 5_{10}\)`, {1,2,3} as `\(111_2 == 7_{10}\)`.

    public ArrayList<ArrayList<Integer>> subsets(int[] num) {
      ArrayList<ArrayList<Integer>> set = new ArrayList<ArrayList<Integer>>();
      for (int i = 0; i < 1 << num.length; i++) {
        ArrayList<Integer> one = generateOne(i, num);
        set.add(one);
      }
      return set;
    }

    public ArrayList<Integer> generateOne(int k, int[] num) {
      ArrayList<Integer> set = new ArrayList<Integer>();
      for (int i = 0; i < num.length; i++) {
        if ((k & (1 << i)) != 0) {
          set.add(num[i]);
        }
      }
      return set;
    }

## Follow up

### Subsets in Range [a,b]

Actually, this problem could also be described as retrieving Combinations (n,a), (n,a+1) ... (n,b).

We can generate those Combinations one by one, using same apporaches in __Combination__; or here is another choise: __binary operation__.

Remember in the last approach of Subset, we generate all the subsets using numbers from 0 ~ `\(2^n\)`. During these numbers, should we have a function to judge how many `1's` is in each number, we could generating Subsets in ranger [a,b] by checking number of `1's` is in ranger [a,b].

    public ArrayList<ArrayList<Integer>> subsetsInRange(int[] num, int a, int b) {
      ArrayList<ArrayList<Integer>> set = new ArrayList<ArrayList<Integer>>();
      for (int i = 0; i < 1 << num.length; i++) {
        int numberOf1bit = numberOf1(i);
        if (numberOf1bit >= a && numberOf1bit <=b) {
          ArrayList<Integer> one = generateOne(i, num);
          set.add(one);
        }
      }
      return set;
    }

    /*ref: http://codercareer.blogspot.com/2011/11/no-20-number-of-1-in-binary.html */
    public int numberOf1(int n)
    {
      int count = 0;
      while (n != 0)
      {
        ++ count;
        n = (n - 1) & n;
      }
      return count;
    }

### With Duplicated Characters

also see: LeetCode: [Subsets II](https://oj.leetcode.com/problems/subsets-ii/)

### Combination Sum

[Print All Combinations of a Number as a Sum of Candidate Numbers](http://leetcode.com/2010/09/print-all-combinations-of-number-as-sum.html)

alse see: LeetCode: [Combination Sum]() [Combination Sum II]()

## References

<blockquote>
<a href="http://blog.csdn.net/yutianzuijin/article/details/13160011">Permutations and Subsets of a collection</a> -- mostly using DFS, a Chinese post from CSDN, 集合元素的排列与子集 <br/> 
这篇博客的优点是画出了树形式的解空间，帮助理解递归调用。
</blockquote>



